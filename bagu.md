三次握手的原因*
==第三次握手是为了**防止失效的连接请求到达服务器**/防止服务器错误打开连接从而避免资源浪费==，让服务器错误打开连接。
客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。
总：防止服务器错误打开连接，比如client第一次的请求超时滞留，请求会超时重传，如果没有第三次握手，server会打开两个连接；如果有三次握手，不会再次打开连接
![](3handshake.png)
## *不是四次握手的原因*
* 不能显著增加可靠性，没必要

## *四次挥手的原因*
* 关闭连接时，客户端向服务端发送 FIN时，仅仅表示客户端不再发送数据了但是还能接收数据。
* 服务器收到客户端的  FIN 报文时，先回一个 ACK[应答报文](https://www.zhihu.com/search?q=%E5%BA%94%E7%AD%94%E6%8A%A5%E6%96%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2306127873%7D) ，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 ### FIN

 报文给客户端来表示同意现在关闭连接。
* **服务端通常需要等待完成数据的发送和处理，所以服务端的****ACK****和****FIN****一般都会分开发送，从而比三次握手导致多了一次。**


客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 ==CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。==
**为了确保TCP连接的可靠关闭，防止连接中残留的数据报错传到下一个连接中。**

*TIME_WAIT*
客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：
##  2MSL  原因/time_wait原因？
* **确保最后一个确认报文能够到达。**如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
* 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，**使得下一个新的连接不会出现旧的连接请求报文。*==本次连接的所有的报文都已经从网络中消失，从而不会出现在下次连接中*==**

## TCP 挥手可以只需要三次吗？
可以的。
因为 [服务器端](https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2306127873%7D) 收到客户端的FIN后，**服务器端同时也要关闭连接**，这样就可以把ACK和FIN合并到一起发送，节省了一个包，变成了“三次挥手”。 ~（也就是server不发送，同时关闭，把ack和fin合并）~

*为什么不是五次？*
全双工，所以四次靠谱，五次多余浪费，太复杂，三次也是第二次和第三次合并。


### 递归
* 主机向本地域名服务器的查询一般都是采用递归查询。
  * 本地域名server 替主机问，**帮忙问别人**

### 迭代
* 本地域名服务器向根域名服务器的查询的**迭代查询**。
  * 要么给出所要查询的ip地址，要么**指路**


